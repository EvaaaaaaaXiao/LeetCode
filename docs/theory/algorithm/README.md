## 位运算

> 计算机对二进制数据进行的运算(`+`、`-`、`*`、`/`) 都是叫`位运算`
> 
> 知乎用户推荐 [Matrix67的《位运算简介及实用技巧》(一)](http://www.matrix67.com/blog/archives/263)

计算机中的数在内存中都是以二进制形式进行存储的，用位运算就是直接对整数在内存中的二进制位进行操作，因此其执行效率非常高，在程序中尽量使用位运算进行操作，这会大大提高程序的性能。

### 位操作符

- & 与运算 两个位都是 1 时，结果才为 1，否则为 0，如
    1 0 0 1 1 
  &  1 1 0 0 1 
  `------------------------------` 
    1 0 0 0 1 


- | 或运算 两个位都是 0 时，结果才为 0，否则为 1，如
    1 0 0 1 1 
  |   1 1 0 0 1 
  `------------------------------` 
    1 1 0 1 1 


- ^ 异或运算，两个位相同则为 0，不同则为 1，如
    1 0 0 1 1 
  ^  1 1 0 0 1 
  `-----------------------------` 
    0 1 0 1 0 


- ~ 取反运算，0 则变为 1，1 则变为 0，如
  ~   1 0 0 1 1 
  `-----------------------------` 
     0 1 1 0 0 


- << 左移运算，向左进行移位操作，高位丢弃，低位补 0，如

```text
int a = 8;
a << 3;
移位前：0000 0000 0000 0000 0000 0000 0000 1000
移位后：0000 0000 0000 0000 0000 0000 0100 0000
```

\>> 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，如

```text
unsigned int a = 8;
a >> 3;
移位前：0000 0000 0000 0000 0000 0000 0000 1000
移位后：0000 0000 0000 0000 0000 0000 0000 0001

int a = -8;
a >> 3;
移位前：1111 1111 1111 1111 1111 1111 1111 1000
移位前：1111 1111 1111 1111 1111 1111 1111 1111
```

### 常见位运算问题

#### 1. 位操作实现乘除法

- 数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2

```text
int a = 2;
a >> 1; ---> 1
a << 1; ---> 4
```

#### 2. 位操作交货两数

- 位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高

```text
//普通操作
void swap(int &a, int &b) {
  a = a + b;
  b = a - b;
  a = a - b;
}

//位与操作
void swap(int &a, int &b) {
  a ^= b;
  b ^= a;
  a ^= b;
}
```

位与操作解释：第一步：a ^= b ---> a = (a^b); 

第二步：b ^= a ---> b = b^(a^b) ---> b = (b^b)^a = a

第三步：a ^= b ---> a = (a^b)^a = (a^a)^b = b



> 作者：力扣（LeetCode）
>
> 链接：https://www.zhihu.com/question/38206659/answer/736472332
>
> 来源：知乎
>
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> 更多查看知乎 [位运算有什么奇技淫巧？](https://www.zhihu.com/question/38206659)
>





## KMP算法 (字符串匹配)

> 算法解释自行整理自[阮一峰的《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

> KMP是从前往后匹配

Knuth-Morris-Pratt算法（简称KMP）是最常用的**字符串匹配**算法之一

在了解算法的具体操作过程之前，先要对算法中会用到的内容进行一个了解

### 部分匹配表

在这个算法里需要用到一个**部分匹配表**，字符串的每个元素都对应着一个**部分匹配值**，那么怎么计算这个值呢？

**部分匹配值**是首个元素到当前元素的这段子字符串的**所有前缀**和**所有后缀**的最长共有元素的长度，**即这段子字符串头尾连续重合的元素长度！**

以 `ABCDABD` 为例：

```
- "A"的前缀和后缀都为空集，共有元素的长度为0
-  A 对应的部分匹配值为 0

- "AB"的前缀为[A]，后缀为[B]，共有元素的长度为0
-  B 对应的部分匹配值为 0

- "ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0
-  C 对应的部分匹配值为 0

- "ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0
-  D 对应的部分匹配值为 0

- "ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1
- ！！也可以理解为"ABCDA"的头尾连续重合的元素为A，长度为1
-  A 对应的部分匹配值为 1

- "ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2
- ！！也可以理解为"ABCDAB"的头尾连续重合的元素为AB，长度为2
-  B 对应的部分匹配值为 2

- "ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0
-  B 对应的部分匹配值为 0
```

可得出 `ABCDABD` 的部分匹配表为

|   A   |   B   |   C   |   D   |   A   |   B   |   D   |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |
|   0   |   0   |   0   |   0   |   1   |   2   |   0   |

### 移位公式

在算法中，遇到没有匹配上的元素时，为了避免重复比较已经比较过的内容，就**不会**每次只是往后移动一位，而是利用已知的已经匹配上的内容，进行移位，从而提高整体的效率。

具体运用到的公式如下

```
移动的位数 = 已匹配的元素个数 - 最后一个匹配上的元素对应的部分匹配值
```

### 算法过程

了解了前面两块内容后，就可以开始了解整个KMP算法的过程了

以 `BABCDAB ABCDABD` 和 `ABCDABD` 为例：

1、
```
BABCDAB ABCDABD
ABCDABD
```
**首个元素** ' A ' 与 'B' 未能匹配上，此时**直接后移一位**

2、
```
BABCDAB ABCDABD
 ABCDABD
```
一位位比较，发现' D ' 与 '  ' 未能匹配上，此时算法知道前面已匹配上的内容是 `ABCDAB` ，那么往后移一位也肯定是无法匹配上的，所以利用**最后一个匹配上的元素**  ' B ' 对应的部分匹配值按照移位公式来移动 `6 - 2 = 4` 位

3、
```
BABCDAB ABCDABD
     ABCDABD
```
发现' C ' 与 '  ' 未能匹配上，利用**最后一个匹配上的元素**  ' B ' 对应的部分匹配值按照移位公式来移动 `2 - 0 = 2` 位

4、
```
BABCDAB ABCDABD
       ABCDABD
```
首个元素 ' A ' 与 '  ' 未能匹配上，直接后移一位

5、
```
BABCDAB ABCDABD
        ABCDABD
```
发现完全匹配，于是完成了**首次匹配**。当然如果要找出全部匹配，可以根据具体内容继续，直到最后一位




## BM算法 (字符串匹配)

> 算法解释自行整理自
> [阮一峰的《字符串匹配的Boyer-Moore算法》](http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)
> [匠心十年的《Boyer-Moore 字符串匹配算法》](https://www.cnblogs.com/gaochundong/p/boyer_moore_string_matching_algorithm.html)

> BM是从后往前匹配

各种文本编辑器的"查找"功能（Ctrl+F），大多采用Boyer-Moore算法，效率比KMP算法要高

依然先要做一些事前知识准备

### 坏字符（Bad Character Heuristic）

遇到无法匹配的元素时，称文本中的这个元素为**坏字符**。

### 好后缀（Good Suffix Heuristic）

遇到无法匹配的元素时，在这之前已经匹配上的字符串的所有后缀都是**好后缀**

### 移位公式

#### 坏字符规则

具体运用到的公式如下

```
移动的位数 = 无法匹配的元素的位置 - 坏字符在匹配内容中最后一次出现的位置
```

1. 若坏字符中并不存在，则在匹配内容中最后一次出现的位置取值-1
2. 若坏字符在匹配内容中最后一次出现的位置在无法匹配的元素的右侧，即**存在在已经匹配上的好后缀之中，该规则不适用**

#### 好后缀规则

具体运用到的公式如下

```
移动的位数 = 好后缀的最后一位元素的位置 - 好后缀前一次在匹配内容中出现时最后一位元素的位置
```

以 `ABCDAB` 为例，如果字符串后部的"AB"是"好后缀"，那么此时所有的好后缀为 `AB` 、`B`
- "AB" : 出现在字符串的头部了，最后一位元素 `B` 的位置为 1；
- "B" : 没有出现在字符串的头部，最后一位元素的位置为 -1；

#### 规则选取

在又有坏字符又有好后缀的时候，比较两个规则算出的移动位数，选取**值更大**的作为最终移位数



### 算法过程

以 `HERE IS A SIMPLE EXAMPLE` 和 `EXAMPLE` 为例：

1、
```
HERE IS A SIMPLE EXAMPLE
EXAMPLE
```
从尾部开始进行匹配，如果尾部无法匹配，则前面的内容也无需比较了。发现 ' S ' 和 ' E ' 未能匹配上，则称文本中的 ' S ' 为坏字符，且匹配内容中并不含 ' S ' ，所以按照坏字符规则来移动 `6 - (-1) = 7` 位

2、
```
HERE IS A SIMPLE EXAMPLE
       EXAMPLE
```
发现 ' P ' 和 ' E ' 未能匹配上，则称文本中的 ' P ' 为坏字符，匹配内容中含有 ' P ' ，' P '最后一次出现的位置为4，所以按照坏字符规则来移动 `6 - (4) = 2` 位

3、
```
HERE IS A SIMPLE EXAMPLE
         EXAMPLE
```
发现' I ' 与 ' A ' 未能匹配上，则称文本中的 ' I ' 为坏字符。
按照坏字符规则将移动 `2 - (-1) = 3` 位。

此时，在这之前已匹配上了 ' MPLE ' ，则称 ' MPLE ' 为好后缀，所有好后缀有  ' MPLE ' 、 ' PLE ' 、 ' LE ' 、 ' E ' ，按照好后缀规则我们可以分析
-  ' MPLE ' : 没有出现在字符串的头部，最后一位元素的位置为 -1；
-  ' PLE ' : 没有出现在字符串的头部，最后一位元素的位置为 -1；
-  ' LE ' : 没有出现在字符串的头部，最后一位元素的位置为 -1；
-  ' E ' : 出现在字符串的头部了，最后一位元素的位置为 0，其实可以把整体看成 (MPL)EXAMPLE 更好理解；
按照好后缀规则将移动 `6 - (0) = 6` 位。

由于好后缀的移动位数更大，所以按照好后缀规则来移动 6 位

4、
```
HERE IS A SIMPLE EXAMPLE
               EXAMPLE
```
发现 ' P ' 和 ' E ' 未能匹配上，所以按照坏字符规则来移动 `6 - (4) = 2` 位

5、
```
HERE IS A SIMPLE EXAMPLE
                 EXAMPLE
```
发现完全匹配，于是完成了**首次匹配**。当然如果要找出全部匹配，可以根据具体内容继续，直到最后一位




## 二分查找

> 算法解释自行整理自
> [LeetCode用户@liweiwei1419的《用“排除法”（减治思想）写二分查找问题》](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)

