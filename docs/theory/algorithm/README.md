## KMP算法 (字符串匹配)

> 算法解释自行整理自[阮一峰的字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

Knuth-Morris-Pratt算法（简称KMP）是最常用的**字符串匹配**算法之一

在了解算法的具体操作过程之前，先要对算法中会用到的内容进行一个了解

### 部分匹配表

在这个算法里需要用到一个**部分匹配表**，字符串的每个元素都对应着一个**部分匹配值**，那么怎么计算这个值呢？

**部分匹配值**是首个元素到当前元素的这段子字符串的**所有前缀**和**所有后缀**的最长共有元素的长度，**即这段子字符串头尾连续重合的元素长度！**

以 `ABCDABD` 为例：

```
- "A"的前缀和后缀都为空集，共有元素的长度为0
-  A 对应的部分匹配值为 0

- "AB"的前缀为[A]，后缀为[B]，共有元素的长度为0
-  B 对应的部分匹配值为 0

- "ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0
-  C 对应的部分匹配值为 0

- "ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0
-  D 对应的部分匹配值为 0

- "ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1
- ！！也可以理解为"ABCDA"的头尾连续重合的元素为A，长度为1
-  A 对应的部分匹配值为 1

- "ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2
- ！！也可以理解为"ABCDAB"的头尾连续重合的元素为AB，长度为2
-  B 对应的部分匹配值为 2

- "ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0
-  B 对应的部分匹配值为 0
```

可得出 `ABCDABD` 的部分匹配表为

|   A   |   B   |   C   |   D   |   A   |   B   |   D   |
| ----- | ----- | ----- | ----- | ----- | ----- | ----- |
|   0   |   0   |   0   |   0   |   1   |   2   |   0   |

### 移位公式

在算法中，遇到没有匹配上的元素时，为了避免重复比较已经比较过的内容，就**不会**每次只是往后移动一位，而是利用已知的已经匹配上的内容，进行移位，从而提高整体的效率。

具体运用到的公式如下

```
移动的位数 = 已匹配的元素个数 - 最后一个匹配上的元素对应的部分匹配值
```

### KMP算法

了解了前面两块内容后，就可以开始了解整个KMP算法的过程了

以 `BABCDAB ABCDABD` 和 `ABCDABD` 为例：

1. 
```
BABCDAB ABCDABD
ABCDABD
```
**首个元素** ' A ' 与 'B' 未能匹配上，此时**直接后移一位**

2. 
```
BABCDAB ABCDABD
 ABCDABD
```
一位位比较，发现' D ' 与 '  ' 未能匹配上，此时算法知道前面已匹配上的内容是 `ABCDAB` ，那么往后移一位也肯定是无法匹配上的，所以利用**最后一个匹配上的元素**  ' B ' 对应的部分匹配值按照移位公式来移动 `6 - 2 = 4` 位

3. 
```
BABCDAB ABCDABD
     ABCDABD
```
发现' C ' 与 '  ' 未能匹配上，利用**最后一个匹配上的元素**  ' B ' 对应的部分匹配值按照移位公式来移动 `2 - 0 = 2` 位

4. 
```
BABCDAB ABCDABD
       ABCDABD
```
首个元素 ' A ' 与 '  ' 未能匹配上，直接后移一位

5. 
```
BABCDAB ABCDABD
        ABCDABD
```
发现完全匹配，于是完成了**首次匹配**。当然如果要找出全部匹配，可以根据具体内容继续，直到最后一位

